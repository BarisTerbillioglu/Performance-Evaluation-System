# Zustand State Management Guide\n\nThis guide documents the complete Zustand-based state management system implemented for the Performance Evaluation System frontend.\n\n## ðŸ—ï¸ Overview\n\nThe state management system provides:\n- **5 Specialized Stores**: Auth, Evaluation, User, Criteria, and UI stores\n- **Optimistic Updates**: Immediate UI feedback with rollback on failure\n- **Persistence**: Selective state persistence using localStorage\n- **Error Handling**: Comprehensive error states and user notifications\n- **Performance**: Selective subscriptions and memoized selectors\n- **Developer Experience**: Enhanced logging and debugging in development\n\n## ðŸ“ Store Structure\n\n```\nsrc/stores/\nâ”œâ”€â”€ slices/           # Individual store implementations\nâ”‚   â”œâ”€â”€ authStore.ts\nâ”‚   â”œâ”€â”€ evaluationStore.ts\nâ”‚   â”œâ”€â”€ userStore.ts\nâ”‚   â”œâ”€â”€ criteriaStore.ts\nâ”‚   â””â”€â”€ uiStore.ts\nâ”œâ”€â”€ types/            # TypeScript interfaces for stores\nâ”‚   â”œâ”€â”€ auth.ts\nâ”‚   â”œâ”€â”€ evaluation.ts\nâ”‚   â”œâ”€â”€ user.ts\nâ”‚   â”œâ”€â”€ criteria.ts\nâ”‚   â””â”€â”€ ui.ts\nâ”œâ”€â”€ middleware/       # Custom Zustand middleware\nâ”‚   â”œâ”€â”€ persist.ts\nâ”‚   â””â”€â”€ logger.ts\nâ””â”€â”€ index.ts         # Main exports\n```\n\n## ðŸ” Auth Store\n\n### Features\n- JWT token management with HTTP-only cookies\n- Role-based permission checking\n- Automatic token refresh (every 14 minutes)\n- Persistent auth state with selective persistence\n- RBAC integration with route and component guards\n\n### Usage\n\n```typescript\nimport { useAuthStore } from '@/stores';\n\n// Using the store directly\nconst MyComponent = () => {\n  const { user, isAuthenticated, login, logout, hasRole } = useAuthStore();\n  \n  const handleLogin = async () => {\n    try {\n      await login({ email: 'user@example.com', password: 'password' });\n    } catch (error) {\n      console.error('Login failed:', error);\n    }\n  };\n  \n  return (\n    <div>\n      {isAuthenticated ? (\n        <div>\n          <p>Welcome, {user?.firstName}!</p>\n          {hasRole('Admin') && <AdminPanel />}\n          <button onClick={logout}>Logout</button>\n        </div>\n      ) : (\n        <button onClick={handleLogin}>Login</button>\n      )}\n    </div>\n  );\n};\n\n// Using the compatibility hook\nimport { useAuth } from '@/hooks';\n\nconst CompatibleComponent = () => {\n  const { state, login, hasRole } = useAuth();\n  // Same interface as the old React Context version\n};\n```\n\n### Selectors for Performance\n\n```typescript\nimport { useAuthStore, authSelectors } from '@/stores';\n\n// Optimized selectors prevent unnecessary re-renders\nconst user = useAuthStore(authSelectors.user);\nconst isAuthenticated = useAuthStore(authSelectors.isAuthenticated);\nconst primaryRole = useAuthStore(authSelectors.primaryRole);\n```\n\n## ðŸ“Š Evaluation Store\n\n### Features\n- CRUD operations for evaluations, scores, and comments\n- Optimistic updates for scores and comments\n- Cache management with timestamps\n- Form state management\n- Status transitions (Draft â†’ Submitted â†’ Completed)\n\n### Usage\n\n```typescript\nimport { useEvaluationStore } from '@/stores';\n\nconst EvaluationList = () => {\n  const {\n    evaluations,\n    isLoading,\n    fetchEvaluations,\n    createEvaluation,\n    updateScoreOptimistic\n  } = useEvaluationStore();\n  \n  useEffect(() => {\n    fetchEvaluations();\n  }, [fetchEvaluations]);\n  \n  const handleScoreChange = (evaluationId: number, criteriaId: number, score: number) => {\n    // Optimistic update - immediate UI feedback\n    updateScoreOptimistic(evaluationId, criteriaId, score);\n    \n    // Actual API call happens in background\n    updateScore(evaluationId, { criteriaId, score });\n  };\n  \n  return (\n    <div>\n      {isLoading ? (\n        <LoadingSpinner />\n      ) : (\n        evaluations.map(evaluation => (\n          <EvaluationCard key={evaluation.id} evaluation={evaluation} />\n        ))\n      )}\n    </div>\n  );\n};\n```\n\n## ðŸ‘¥ User Store\n\n### Features\n- User, department, and team management\n- Role-based user lists (employees, evaluators)\n- Search and filtering capabilities\n- Pagination support\n- Optimistic updates for user operations\n\n### Usage\n\n```typescript\nimport { useUserStore } from '@/stores';\n\nconst UserManagement = () => {\n  const {\n    users,\n    departments,\n    teams,\n    searchTerm,\n    setSearchTerm,\n    fetchUsers,\n    createUser,\n    updateUserOptimistic\n  } = useUserStore();\n  \n  const handleUserUpdate = async (userId: number, data: any) => {\n    // Optimistic update\n    updateUserOptimistic(userId, data);\n    \n    try {\n      await updateUser(userId, data);\n    } catch (error) {\n      // Revert optimistic update on failure\n      fetchUsers(); // Refetch to get correct state\n    }\n  };\n  \n  return (\n    <div>\n      <SearchInput \n        value={searchTerm} \n        onChange={setSearchTerm} \n      />\n      <UserList users={users} onUpdate={handleUserUpdate} />\n    </div>\n  );\n};\n```\n\n## ðŸ“‹ Criteria Store\n\n### Features\n- Criteria and category management\n- Weight validation and rebalancing\n- Role-specific descriptions\n- Active/inactive state management\n- Category hierarchy support\n\n### Usage\n\n```typescript\nimport { useCriteriaStore } from '@/stores';\n\nconst CriteriaManagement = () => {\n  const {\n    criteria,\n    categories,\n    categoryWeights,\n    validateWeights,\n    rebalanceWeights\n  } = useCriteriaStore();\n  \n  const handleWeightChange = async (weights: CategoryWeightDto[]) => {\n    const validation = await validateWeights(weights);\n    \n    if (validation.isValid) {\n      await rebalanceWeights(weights);\n    } else {\n      // Show validation errors\n      console.error('Weight validation failed:', validation.errors);\n    }\n  };\n  \n  return (\n    <div>\n      <CategoriesList categories={categories} />\n      <WeightManager weights={categoryWeights} onChange={handleWeightChange} />\n    </div>\n  );\n};\n```\n\n## ðŸŽ¨ UI Store\n\n### Features\n- Global loading states for all operations\n- Notification system (success, error, warning, info)\n- Modal management with different types\n- Theme and layout preferences\n- Form dirty state tracking\n- Online/offline status\n\n### Usage\n\n#### Notifications\n\n```typescript\nimport { useUIStore } from '@/stores';\n\nconst MyComponent = () => {\n  const { showSuccess, showError, showConfirm } = useUIStore();\n  \n  const handleSave = async () => {\n    try {\n      await saveData();\n      showSuccess('Data saved successfully');\n    } catch (error) {\n      showError('Save failed', error.message);\n    }\n  };\n  \n  const handleDelete = () => {\n    showConfirm(\n      'Confirm Delete',\n      'Are you sure you want to delete this item?',\n      async () => {\n        await deleteItem();\n        showSuccess('Item deleted');\n      }\n    );\n  };\n  \n  return (\n    <div>\n      <button onClick={handleSave}>Save</button>\n      <button onClick={handleDelete}>Delete</button>\n    </div>\n  );\n};\n```\n\n#### Loading States\n\n```typescript\nconst LoadingExample = () => {\n  const { isLoading, setLoading } = useUIStore();\n  \n  const handleAsyncOperation = async () => {\n    setLoading('fetchUsers', true);\n    try {\n      await fetchUsers();\n    } finally {\n      setLoading('fetchUsers', false);\n    }\n  };\n  \n  return (\n    <div>\n      {isLoading('fetchUsers') ? (\n        <LoadingSpinner />\n      ) : (\n        <button onClick={handleAsyncOperation}>Load Users</button>\n      )}\n    </div>\n  );\n};\n```\n\n#### Modals\n\n```typescript\nconst ModalExample = () => {\n  const { showModal } = useUIStore();\n  \n  const openCustomModal = () => {\n    showModal({\n      type: 'custom',\n      title: 'Custom Form',\n      component: UserForm,\n      props: { userId: 123 },\n      size: 'lg'\n    });\n  };\n  \n  return (\n    <button onClick={openCustomModal}>Open Modal</button>\n  );\n};\n```\n\n## ðŸ› ï¸ Middleware\n\n### Persistence Middleware\n\nSelectively persists state to localStorage:\n\n```typescript\n// Auth store persistence (selective)\nconst authStore = create(\n  persist(\n    (set, get) => ({\n      // store implementation\n    }),\n    {\n      name: 'auth-store',\n      partialize: (state) => ({\n        user: state.user,\n        isAuthenticated: state.isAuthenticated,\n        // Don't persist error states or loading states\n      })\n    }\n  )\n);\n```\n\n### Logger Middleware\n\nEnhanced logging in development:\n\n```typescript\nconst store = create(\n  loggerWithActions(\n    (set, get) => ({\n      // store implementation\n    }),\n    {\n      name: 'MyStore',\n      enabled: isDevelopment(),\n      logActions: true,\n      logState: true\n    }\n  )\n);\n```\n\n## âš¡ Optimistic Updates\n\n### Implementation Pattern\n\n```typescript\nconst updateUser = async (id: number, data: UpdateUserRequest) => {\n  try {\n    // 1. Optimistic update\n    const previousUsers = get().users;\n    set((state) => {\n      const userIndex = state.users.findIndex(u => u.id === id);\n      if (userIndex !== -1) {\n        state.users[userIndex] = { ...state.users[userIndex], ...data };\n      }\n    });\n\n    // 2. API call\n    await userService.updateUser(id, data);\n\n    // 3. Success notification\n    useUIStore.getState().showSuccess('User updated successfully');\n    \n    // 4. Optional: Refresh from server\n    get().fetchUsers();\n  } catch (error) {\n    // 5. Revert optimistic update\n    set((state) => {\n      state.users = previousUsers;\n    });\n\n    // 6. Error handling\n    const errorMessage = error instanceof Error ? error.message : 'Update failed';\n    set((state) => {\n      state.error = errorMessage;\n    });\n    useUIStore.getState().showError('Update failed', errorMessage);\n    throw error;\n  }\n};\n```\n\n## ðŸŽ¯ Performance Optimizations\n\n### Selective Subscriptions\n\n```typescript\n// âŒ Bad - subscribes to entire store\nconst { users, evaluations, criteria } = useUserStore();\n\n// âœ… Good - selective subscriptions\nconst users = useUserStore(state => state.users);\nconst isLoading = useUserStore(state => state.isLoading);\n\n// âœ… Best - using selectors\nconst users = useUserStore(userSelectors.users);\nconst isLoading = useUserStore(userSelectors.isLoading);\n```\n\n### Memoized Selectors\n\n```typescript\nexport const userSelectors = {\n  users: (state: UserStore) => state.users,\n  activeUsers: (state: UserStore) => state.users.filter(u => u.isActive),\n  usersByDepartment: (departmentId: number) => (state: UserStore) => \n    state.users.filter(u => u.departmentId === departmentId),\n};\n```\n\n### Cache Management\n\n```typescript\nconst fetchUsers = async () => {\n  // Check cache freshness\n  const lastFetch = get().lastFetch.users;\n  const now = Date.now();\n  const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n  \n  if (lastFetch && (now - lastFetch) < CACHE_DURATION) {\n    return; // Use cached data\n  }\n  \n  // Fetch fresh data\n  set((state) => {\n    state.isLoading = true;\n  });\n  \n  try {\n    const users = await userService.getUsers();\n    set((state) => {\n      state.users = users;\n      state.lastFetch.users = now;\n      state.isLoading = false;\n    });\n  } catch (error) {\n    set((state) => {\n      state.error = error.message;\n      state.isLoading = false;\n    });\n  }\n};\n```\n\n## ðŸ§ª Testing Stores\n\n### Unit Testing\n\n```typescript\nimport { renderHook, act } from '@testing-library/react';\nimport { useUserStore } from '@/stores';\n\ndescribe('UserStore', () => {\n  beforeEach(() => {\n    useUserStore.getState().reset();\n  });\n  \n  it('should add user optimistically', () => {\n    const { result } = renderHook(() => useUserStore());\n    \n    act(() => {\n      result.current.addUserOptimistic({\n        id: 1,\n        firstName: 'John',\n        lastName: 'Doe',\n        email: 'john@example.com'\n      });\n    });\n    \n    expect(result.current.users).toHaveLength(1);\n    expect(result.current.users[0].firstName).toBe('John');\n  });\n});\n```\n\n### Integration Testing\n\n```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { server } from '@/test/mocks/server';\nimport { UserList } from '@/components';\n\ndescribe('UserList Integration', () => {\n  beforeEach(() => {\n    server.listen();\n  });\n  \n  afterEach(() => {\n    server.resetHandlers();\n  });\n  \n  it('should handle user creation with optimistic updates', async () => {\n    render(<UserList />);\n    \n    fireEvent.click(screen.getByText('Add User'));\n    fireEvent.change(screen.getByLabelText('First Name'), {\n      target: { value: 'Jane' }\n    });\n    fireEvent.click(screen.getByText('Save'));\n    \n    // Should show optimistic update immediately\n    expect(screen.getByText('Jane')).toBeInTheDocument();\n    \n    // Should confirm with server response\n    await waitFor(() => {\n      expect(screen.getByText('User created successfully')).toBeInTheDocument();\n    });\n  });\n});\n```\n\n## ðŸ”§ Configuration\n\n### Environment-Based Configuration\n\n```typescript\n// stores/config.ts\nexport const storeConfig = {\n  persistence: {\n    enabled: true,\n    version: 1,\n    migrate: (persistedState: any, version: number) => {\n      if (version < 1) {\n        // Handle migration from older versions\n        return migrateFromV0toV1(persistedState);\n      }\n      return persistedState;\n    }\n  },\n  logging: {\n    enabled: isDevelopment(),\n    logActions: true,\n    logState: true\n  },\n  cache: {\n    defaultTTL: 5 * 60 * 1000, // 5 minutes\n    maxSize: 100 // Maximum number of cached items\n  }\n};\n```\n\n## ðŸ› Debugging\n\n### Redux DevTools Integration\n\n```typescript\nimport { devtools } from 'zustand/middleware';\n\nconst useUserStore = create<UserStore>()()\n  (\n    devtools(\n      immer((set, get) => ({\n        // store implementation\n      })),\n      {\n        name: 'user-store',\n        serialize: {\n          options: {\n            undefined: true,\n            function: true,\n            symbol: true,\n          },\n        },\n      }\n    )\n  );\n```\n\n### Console Logging\n\n```javascript\n// In browser console, access stores directly:\nuseUserStore.getState().users\nuseAuthStore.getState().user\nuseUIStore.getState().notifications\n\n// Trigger actions:\nuseUIStore.getState().showSuccess('Test notification')\nuseUserStore.getState().fetchUsers()\n```\n\n## ðŸ“š Best Practices\n\n### 1. Store Organization\n- Keep stores focused on specific domains\n- Use TypeScript for type safety\n- Implement selectors for performance\n- Use middleware for cross-cutting concerns\n\n### 2. State Management\n- Use Immer for immutable updates\n- Implement optimistic updates for better UX\n- Handle errors gracefully with rollbacks\n- Cache data with TTL for performance\n\n### 3. Component Integration\n- Use selective subscriptions\n- Implement loading and error states\n- Provide fallbacks for offline scenarios\n- Use the UI store for user feedback\n\n### 4. Testing\n- Reset stores before each test\n- Mock API calls consistently\n- Test optimistic updates and rollbacks\n- Verify error handling paths\n\n## ðŸš€ Migration from React Context\n\nThe new Zustand stores are designed to be compatible with the existing React Context API. Use the `useAuth` hook from `@/hooks` for seamless migration:\n\n```typescript\n// Old way (React Context)\nimport { useAuth } from '@/store';\n\n// New way (Zustand compatible)\nimport { useAuth } from '@/hooks';\n\n// Same interface, better performance!\n```\n\nThe Zustand implementation is now complete and ready for production use! ðŸŽ‰\n\n## ðŸ“ˆ Performance Improvements\n\nWith Zustand implementation, you can expect:\n- **Faster re-renders**: Only subscribed components update\n- **Better memory usage**: No unnecessary re-renders\n- **Improved developer experience**: Better debugging tools\n- **Automatic persistence**: Critical state persisted across sessions\n- **Optimistic updates**: Immediate UI feedback\n- **Smart caching**: Reduced API calls with TTL-based cache
